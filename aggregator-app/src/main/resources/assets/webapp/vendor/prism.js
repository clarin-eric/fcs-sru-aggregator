/*!
 * FCS SRU Aggragator UI
 * @module lib/vendor/prism.js
 * @version 1.0.0-alpha
 * @license GPL-3.0-or-later
 * @see {@link https://github.com/clarin-eric/fcs-sru-aggregator-ui.git}
 */const K=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;function ce(a){let e=a;for(;e;e=e.parentElement){const t=K.exec(e.className);if(t)return t[1].toLowerCase()}return"none"}function Z(a,e){a.className=a.className.replace(RegExp(K,"gi"),""),a.classList.add("language-"+e)}function I(a,e,t=!1){return a?.closest(`.${e}, .no-${e}`)?.classList?.contains(e)??t}function le(a){const e=a.parentElement;if(e&&/pre/i.test(e.nodeName))return e}const O=Symbol.for("Prism rest"),F=Symbol.for("Prism tokenize");function Q(a){return a.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")}function _(a,e){Array.isArray(a)?a.forEach(e):a!=null&&e(a,0)}function ue(a){return a.charAt(0).toUpperCase()+a.slice(1)}function pe(a){const[e,...t]=a.split(/-/);return e+t.map(ue).join("")}class H{_data=new Map;has(e){return this._data.has(e)}get(e,t){let n=this._data.get(e);return n===void 0&&(n=t,this._data.set(e,n)),n}set(e,t){this._data.set(e,t)}}class de{_all=new Map;add(e,t){let n=this._all.get(e);n===void 0&&(n=[],this._all.set(e,n));const s=n;return s.push(t),()=>{const o=s.indexOf(t);o!==-1&&s.splice(o,1)}}run(e,t){const n=this._all.get(e);if(!(!n||!n.length))for(const s of n)s(t)}}class he{head;tail;length;constructor(){const e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0}addAfter(e,t){const n=e.next,s={value:t,prev:e,next:n};return e.next=s,n.prev=s,this.length++,s}removeRange(e,t){let n=e.next,s=0;for(;s<t&&n.next!==null;s++)n=n.next;e.next=n,n.prev=e,this.length-=s}toArray(){const e=[];let t=this.head.next;for(;t.next!==null;)e.push(t.value),t=t.next;return e}}function ge(a,e,t){const n=fe(a,e);for(const s in t)n[s]=t[s];return n}function fe(a,e){const t={},n=new Map;function s(r){if(r.pattern){const l={pattern:r.pattern};return r.lookbehind&&(l.lookbehind=r.lookbehind),r.greedy&&(l.greedy=r.greedy),r.alias&&(l.alias=Array.isArray(r.alias)?[...r.alias]:r.alias),r.inside&&(l.inside=i(r.inside)),l}else return r}function o(r){if(r)return Array.isArray(r)?r.map(s):s(r)}function i(r){return r===e?t:typeof r=="string"?r:u(r)}function u(r){let l=n.get(r);if(l===void 0){l=r===a?t:{},n.set(r,l);for(const[x,d]of Object.entries(r))l[x]=o(d);const c=r[O];c!=null&&(l[O]=i(c));const A=r[F];A&&(l[F]=A)}return l}return u(a)}class me{aliasMap=new Map;entries=new Map;Prism;constructor(e){this.Prism=e}resolveAlias(e){return this.aliasMap.get(e)??e}has(e){return this.entries.has(this.resolveAlias(e))}add(...e){const t=new Set,n=s=>{const{id:o}=s;this.entries.has(o)||(this.entries.set(o,{proto:s}),t.add(o),_(s.alias,i=>this.aliasMap.set(i,o)),_(s.require,n),s.plugin&&(this.Prism.plugins[pe(o)]=s.plugin(this.Prism)))};e.forEach(n),this.update(t)}update(e){const t=new Map,n=[],s=u=>{const r=n.indexOf(u);if(r!==n.length-1)throw new Error(`Circular dependency ${n.slice(r).join(" -> ")} not allowed`);const l=this.entries.get(u);return!l||!i(l.proto)?!1:(l.evaluatedGrammar=void 0,l.evaluatedEffect?.(),l.evaluatedEffect=l.proto.effect?.(this.Prism),!0)},o=u=>{let r=t.get(u);return r===void 0&&(n.push(u),r=s(u),n.pop(),t.set(u,r)),r},i=u=>{let r=!1;return _(u.require,({id:l})=>{o(l)&&(r=!0)}),_(u.optional,l=>{o(this.resolveAlias(l))&&(r=!0)}),r||e.has(u.id)};this.entries.forEach((u,r)=>o(r))}getLanguage(e){e=this.resolveAlias(e);const t=this.entries.get(e),n=t?.proto.grammar;if(!n)return;if(t.evaluatedGrammar)return t.evaluatedGrammar;if(typeof n=="object")return t.evaluatedGrammar=n;const s=o=>{const i=this.getLanguage(o);if(!i)throw new Error(`The language ${o} was not found.`);return i};return t.evaluatedGrammar=n({getLanguage:s,getOptionalLanguage:o=>this.getLanguage(o),extend:(o,i)=>ge(s(o),o,i)})}}class z{type;content;alias;length;constructor(e,t,n,s=""){this.type=e,this.content=t,this.alias=n,this.length=s.length}addAlias(e){let t=this.alias;t?Array.isArray(t)||(this.alias=t=[t]):this.alias=t=[],t.push(e)}}/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 */class xe{hooks=new de;components=new me(this);plugins={};highlightAll(e={}){const{root:t,async:n,callback:s}=e,o={callback:s,root:t??document,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',state:new H};this.hooks.run("before-highlightall",o),o.elements=[...o.root.querySelectorAll(o.selector)],this.hooks.run("before-all-elements-highlight",o);for(const i of o.elements)this.highlightElement(i,{async:n,callback:o.callback})}highlightElement(e,t={}){const{async:n,callback:s}=t,o=ce(e),i=this.components.resolveAlias(o),u=this.components.getLanguage(i);Z(e,o);let r=e.parentElement;r&&r.nodeName.toLowerCase()==="pre"&&Z(r,o);const l=e.textContent,c={element:e,language:o,grammar:u,code:l,state:new H},A=x=>{c.highlightedCode=x,this.hooks.run("before-insert",c),c.element.innerHTML=c.highlightedCode,this.hooks.run("after-highlight",c),this.hooks.run("complete",c),s?.(c.element)};if(this.hooks.run("before-sanity-check",c),r=c.element.parentElement,r&&r.nodeName.toLowerCase()==="pre"&&!r.hasAttribute("tabindex")&&r.setAttribute("tabindex","0"),!c.code){this.hooks.run("complete",c),s?.(c.element);return}if(this.hooks.run("before-highlight",c),!c.grammar){A(Q(c.code));return}n?n({language:c.language,code:c.code,grammar:c.grammar}).then(A,x=>console.log(x)):A(this.highlight(c.code,c.language,{grammar:c.grammar}))}highlight(e,t,n){const s=this.components.resolveAlias(t),o=n?.grammar??this.components.getLanguage(s),i={code:e,grammar:o,language:t};if(this.hooks.run("before-tokenize",i),!i.grammar)throw new Error('The language "'+i.language+'" has no grammar.');return i.tokens=this.tokenize(i.code,i.grammar),this.hooks.run("after-tokenize",i),B(i.tokens,i.language,this.hooks)}tokenize(e,t){const n=t[F];if(n)return n(e,t,this);let s=G(this.components,t[O]);for(;s;)t={...t,...s},s=G(this.components,s[O]);const o=new he;return o.addAfter(o.head,e),this._matchGrammar(e,o,t,o.head,0),o.toArray()}_matchGrammar(e,t,n,s,o,i){for(const u in n){const r=n[u];if(!n.hasOwnProperty(u)||!r)continue;const l=Array.isArray(r)?r:[r];for(let c=0;c<l.length;++c){if(i&&i.cause===`${u},${c}`)return;const A=be(l[c]);let{pattern:x,lookbehind:d=!1,greedy:h=!1,alias:L,inside:q}=A;const S=G(this.components,q);h&&!x.global&&(A.pattern=x=RegExp(x.source,x.flags+"g"));for(let p=s.next,f=o;p.next!==null&&!(i&&f>=i.reach);f+=p.value.length,p=p.next){let g=p.value;if(t.length>e.length)return;if(g instanceof z)continue;let w=1,m;if(h){if(m=W(x,f,e,d),!m||m.index>=e.length)break;const P=m.index,ie=m.index+m[0].length;let R=f;for(R+=p.value.length;P>=R;){if(p=p.next,p.next===null)throw new Error("The linked list and the actual text have become de-synced");R+=p.value.length}if(R-=p.value.length,f=R,p.value instanceof z)continue;let T=p;for(;T.next!==null&&(R<ie||typeof T.value=="string");T=T.next)w++,R+=T.value.length;w--,g=e.slice(f,R),m.index-=f}else if(m=W(x,0,g,d),!m)continue;const $=m.index,C=m[0],E=g.slice(0,$),y=g.slice($+C.length),k=f+g.length;i&&k>i.reach&&(i.reach=k);let v=p.prev;E&&(v=t.addAfter(v,E),f+=E.length),t.removeRange(v,w);const N=new z(u,S?this.tokenize(C,S):C,L,C);if(p=t.addAfter(v,N),y&&t.addAfter(p,y),w>1){const P={cause:`${u},${c}`,reach:k};this._matchGrammar(e,t,n,p.prev,f,P),i&&P.reach>i.reach&&(i.reach=P.reach)}}}}}}function W(a,e,t,n){a.lastIndex=e;const s=a.exec(t);if(s&&n&&s[1]){const o=s[1].length;s.index+=o,s[0]=s[0].slice(o)}return s}function B(a,e,t){if(typeof a=="string")return Q(a);if(Array.isArray(a)){let i="";return a.forEach(u=>{i+=B(u,e,t)}),i}const n={type:a.type,content:B(a.content,e,t),tag:"span",classes:["token",a.type],attributes:{},language:e},s=a.alias;s&&(Array.isArray(s)?n.classes.push(...s):n.classes.push(s)),t.run("wrap",n);let o="";for(const i in n.attributes)o+=" "+i+'="'+(n.attributes[i]||"").replace(/"/g,"&quot;")+'"';return"<"+n.tag+' class="'+n.classes.join(" ")+'"'+o+">"+n.content+"</"+n.tag+">"}function be(a){return a.pattern?a:{pattern:a}}function G(a,e){if(e)return typeof e=="string"?a.getLanguage(e):e}const Ee=Symbol.for("Prism global"),ye=globalThis,Y=ye[Ee]??=new xe,ke={id:"plain",alias:["text","txt","plaintext"],grammar:{}},Ae={id:"regex",grammar(){const a={pattern:/\\[\\(){}[\]^$+*?|.]/,alias:"escape"},e=/\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/,t={pattern:/\.|\\[wsd]|\\p\{[^{}]+\}/i,alias:"class-name"},n={pattern:/\\[wsd]|\\p\{[^{}]+\}/i,alias:"class-name"},s="(?:[^\\\\-]|"+e.source+")",o=RegExp(s+"-"+s),i={pattern:/(<|')[^<>']+(?=[>']$)/,lookbehind:!0,alias:"variable"};return{"char-class":{pattern:/((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,lookbehind:!0,inside:{"char-class-negation":{pattern:/(^\[)\^/,lookbehind:!0,alias:"operator"},"char-class-punctuation":{pattern:/^\[|\]$/,alias:"punctuation"},range:{pattern:o,inside:{escape:e,"range-punctuation":{pattern:/-/,alias:"operator"}}},"special-escape":a,"char-set":n,escape:e}},"special-escape":a,"char-set":t,backreference:[{pattern:/\\(?![123][0-7]{2})[1-9]/,alias:"keyword"},{pattern:/\\k<[^<>']+>/,alias:"keyword",inside:{"group-name":i}}],anchor:{pattern:/[$^]|\\[ABbGZz]/,alias:"function"},escape:e,group:[{pattern:/\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,alias:"punctuation",inside:{"group-name":i}},{pattern:/\)/,alias:"punctuation"}],quantifier:{pattern:/(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,alias:"number"},alternation:{pattern:/\|/,alias:"keyword"}}}},V=/\b(?:AND|NOT|OR|PROX)\b/i,we=/(?:"(?:\\[\s\S]|(?!")[^\\])*")/,ve=/[^\s()=<>"/]+/,b=RegExp("(?:"+we.source+"|"+ve.source+")"),Re=b,j=/(?:<>|[=><]=?)/,ee=RegExp("(?:"+j.source+"|"+Re.source+")"),te=RegExp("/\\s*"+b.source+"(?:\\s*"+j.source+"\\s*"+b.source+")?"),ne=RegExp("(?:\\s*"+te.source+")*"),Le=RegExp(ee.source+ne.source),D={pattern:te,inside:{modifier:{pattern:RegExp("(/\\s*)"+b.source),lookbehind:!0,alias:"property"},value:{pattern:RegExp(b.source+"$"),alias:"string"},comparitor:{pattern:j,alias:"operator"},punctuation:/\//}},Se={pattern:RegExp("(?:"+b.source+"\\s*"+Le.source+"\\s*)?"+b.source),inside:{term:{pattern:RegExp(b.source+"(?!.)"),alias:"string"},index:{pattern:RegExp("^"+b.source),alias:"property"},"relation-modifier":D,relation:{pattern:ee,alias:"operator"}}},Ce={pattern:RegExp(V.source+ne.source,"i"),inside:{boolean:{pattern:V,alias:"operator"},"boolean-modifier":D}},qe={pattern:RegExp("(^\\s*)>\\s*(?:"+b.source+"\\s*=\\s*)?"+b.source),lookbehind:!0,inside:{uri:{pattern:RegExp(b.source+"$"),alias:"string"},prefix:{pattern:b,alias:"property"},punctuation:/[>=]/}},$e={pattern:RegExp("(^|\\s)sortby\\b(?:"+b.source+"\\b|[\\s=></])+$","i"),inside:{keyword:/sortby/i,"sortby-index-modifier":D,index:{pattern:b,alias:"property"}}},se={id:"cql",grammar:()=>({prefix:qe,sortby:$e,"bool-group":Ce,"search-clause":Se,punctuation:/[()]/})},Ne={id:"fcs-cql",grammar:()=>({punctuation:/[()]/,operator:{pattern:/(\S\s)\b(?:AND|OR)\b/i,greedy:!0,lookbehind:!0},string:{pattern:/("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},"string-unquoted":{pattern:/\S+/,alias:"string"}})},M=/[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?/,X=RegExp("\\b(?:"+M.source+":)?(?:"+M.source+")\\b(?=\\s*[!=])"),U=/("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,re=/\/(?:[iIcCld]+)/,J=/=|!=/,ae={pattern:U,alias:"regex",inside:{escape:/\\(?:[\\'"nt.^$*+?(){[|]|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{2})/,"invalid-escape":/\\[\s\S]/,whitespace:/\u0009|\u000A|\u000B|\u000C|\u000D|\u0020|\u0085|\u00A0|\u1680|\u2000|\u2001|\u2002|\u2003|\u2004|\u2005|\u2006|\u2007|\u2008|\u2009|\u200A|\u2028|\u2029|\u202F|\u205F|\u3000/}},oe={pattern:re,inside:{punctuation:/\//,keyword:/\w/}},Pe={pattern:RegExp(X.source+"\\s*(?:"+J.source+")\\s*"+U.source+"(?:\\s*"+re.source+")?"),inside:{attribute:{pattern:X,alias:"property",inside:{qualifier:{pattern:RegExp(M.source+"(?=:)"),alias:"class-name"},punctuation:/:/,identifier:{pattern:M,alias:"class-name"}}},regexp:ae,operator:J,"regexp-flag":oe}},Te={id:"fcs-fcsql",grammar:()=>({segment:{pattern:/\[.*?(?:[|&()=]\s*(?:("|')(\\[\s\S]|(?!\1)[^\\])*\1)[^\]=]*?)*\]/,inside:{"basic-expression":Pe,"invalid-expression":U,operator:/[!&|]/,punctuation:/[()[\]]/}},string:ae,quantifier:{pattern:/(?:[*+?])|\{(?:\d+|\d+,|,\d+|\d+,\d+)\}/,alias:"operator",inside:{number:/\d+/,punctuation:/[{},]/}},"regexp-flag":oe,within:{pattern:/within\s+\b(?:p|paragraph|s|sentence|session|t|text|turn|u|utterance)\b/,inside:{keyword:/\w+/}},operator:/\|/,punctuation:/[{}[\](),]/})},_e=["AND","NOT","OR"],Oe=["antonym","baseform","case","citation","definition","entryId","etymology","frequency","gender","holonym","hypernym","hyponym","lang","lemma","meronym","number","phonetic","pos","ref","related","segmentation","senseRef","sentiment","subordinate","superordinate","synonym","transcription","translation"],Me=["fullMatch","honorWhitespace","ignoreAccents","ignoreCase","lang","masked","partialMatch","regexp","respectAccents","respectCase","unmasked"],Ie={id:"fcs-lexcql",require:se,grammar({extend:a}){const e=a("cql",{});delete e.prefix,delete e.sortby;const t=e["bool-group"].inside,n=e["search-clause"].inside,s=n["relation-modifier"].inside,o=RegExp("\\b(?:"+_e.toSorted().join("|")+")\\b","i");t.boolean.pattern=o;const i=new RegExp("(?:(?:<>|(?<!<|>)==?)(?![=><])|\\b(?:exact|is|scr)\\b)");n.relation.pattern=i;const u=RegExp("^\\b(?:"+Oe.toSorted().join("|")+")\\b");n.index.pattern=u;const r=RegExp("(/\\s*)(?:"+Me.toSorted().join("|")+")");return s.modifier.pattern=r,s.comparitor.pattern=/=/,e}},ze={id:"match-braces",effect(a){function e(d){const h=a.plugins.customClass;return h?h.apply(d):d}const t={"(":")","[":"]","{":"}"},n={"(":"brace-round","[":"brace-square","{":"brace-curly"},s={"${":"{"},o=12;let i=0;const u=/^(pair-\d+-)(close|open)$/;function r(d){const h=u.exec(d.id);return h?document.querySelector("#"+h[1]+(h[2]==="open"?"close":"open")):null}function l(){if(!I(this,"brace-hover",!0))return;const d=r(this);d&&[this,d].forEach(h=>{h.classList.add(e("brace-hover"))})}function c(){const d=r(this);d&&[this,d].forEach(h=>{h.classList.remove(e("brace-hover"))})}function A(){if(!I(this,"brace-select",!0))return;const d=r(this);d&&[this,d].forEach(h=>{h.classList.add(e("brace-selected"))})}const x=new WeakSet;return a.hooks.add("complete",d=>{const h=d.element,L=le(h);if(!L)return;const q=[];if(I(h,"match-braces")&&q.push("(","[","{"),q.length===0)return;x.has(L)||(x.add(L),L.addEventListener("mousedown",()=>{const g=L.querySelector("code"),w=e("brace-selected");g?.querySelectorAll("."+w).forEach(m=>{m.classList.remove(w)})}));const S=[...h.querySelectorAll("span."+e("token")+"."+e("punctuation"))],p=[];q.forEach(g=>{const w=t[g],m=e(n[g]),$=[],C=[];for(let E=0;E<S.length;E++){const y=S[E];if(y.childElementCount===0){let k=y.textContent||"";if(k=s[k]||k,k===g)p.push({index:E,open:!0,element:y}),y.classList.add(m),y.classList.add(e("brace-open")),C.push(E);else if(k===w){p.push({index:E,open:!1,element:y}),y.classList.add(m),y.classList.add(e("brace-close"));const v=C.pop();v!==void 0&&$.push([E,v])}}}$.forEach(E=>{const y=`pair-${i++}-`,k=S[E[0]],v=S[E[1]];k.id=y+"open",v.id=y+"close",[k,v].forEach(N=>{N.addEventListener("mouseenter",l),N.addEventListener("mouseleave",c),N.addEventListener("click",A)})})});let f=0;p.sort((g,w)=>g.index-w.index),p.forEach(g=>{g.open?(g.element.classList.add(e(`brace-level-${f%o+1}`)),f++):(f=Math.max(0,f-1),g.element.classList.add(e(`brace-level-${f%o+1}`)))})})}},Ge=[ke,Ae,se,Ne,Te,Ie],Fe=[ze];Y.components.add(...Ge);Y.components.add(...Fe);export{Y as g};
